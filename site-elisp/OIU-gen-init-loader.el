;;; -*- mode: emacs-lisp; coding: utf-8-unix; -*-
;;; OIU-gen-init-loader.el --- emacs init-loader generator

;; Copyright (c) 2016 satocis
;;
;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:
;;
;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.
;;
;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.;; This program is free software; you can redistribute it
;; and/or modify
;;
;;; Author: satocis <satocis@users.noreply.github.com>
;;; Keywords: files
;;
;;; Usage:
;;  1) Put in this script to your `load-path'
;;  2) Add special line to your initialize files (see below)
;;  3) Place those files to directory(ies) (not need adding to `load-path')
;;  4) Customize some variables if you need (see below)
;;  5) Load script and run `OIU-generate-init-loader'
;;  6) If done successfully, `_init-loader.el' file generated
;;  7) Load it from `USER-EMACS-DIR/init.el' etc.
;;
;;  Dependency definition line:
;;      Example:
;;          ;;;@#@ ("require-init" "other-requires"...)
;;
;;      - Each init-file is identified by it's filename (exclude extension)
;;      - Each init-file have zero or one dependency definition line
;;      - That line beginning a special indicator given the variable
;;        `OIU-dependency-line-begin' (default value is `;;;@#@')
;;      - Following part must be a valid lisp list include strings
;;      - That line define it's dependency
;;      - strings are REQUIRED init-file names
;;
;;      Example's list means the init file require 2 init-files.
;;      When this script generate a loader file from include previous
;;      definition, the loader must load the init-file after the others.
;;
;;  Note:
;;      - This script delete target file first if its exists
;;      - If circular definition is found, stop and generate nothing
;;        - This means, if error occurred, you lost current `_init-loader.el'
;;      - Init-file names conflicting is not allow
;;
;;; Todo:
;;  - bytecompe init-files to faster loading
;;  - eval (count-matches "todo")
;;
;;; Commentary:
;;; Code:

(provide 'OIU-gen-init-loader)
(eval-when-compile (require 'cl))

(defvar OIU-init-file-root-directory
  (concat user-emacs-directory "conf.d/"))
(defvar OIU-init-loader-filename
  (concat user-emacs-directory "_init-loader.el"))
(defvar OIU-init-file-directories nil)
(defvar OIU-init-filename-regexp "^[^_].*\\.el\\'"
  "Regexp for to include init-files by `_init-loader.el'.
Default \"^[^_].*\\\\.el\\\\'\" means `.el' files exclude beginning from `_'.")

(defvar OIU-dependency-line-begin ";;;@#@"
  "TODO: Write DocString.")

(defvar OIU-init-loader-file-header
  ";;; -*- coding: utf-8-unix; -*-
;;; %s --- user init file loader
;;; generated by `OIU-gen-init-loader.el' automatically ***DO NOT EDIT MANUALLY***\n"
  "TODO: Write DocString.")

(defun OIU-generate-init-loader ()
  "Generate `init-loader' from init files in given directories."
  ;; delete `OIU-init-loader-filename' if it exists
  (if (file-exists-p OIU-init-loader-filename)
      (when (yes-or-no-p (format "Delete & update file '%s'?"
                                 OIU-init-loader-filename))
        (delete-file OIU-init-loader-filename)
        (_OIU-generate-init-loader-do))
    (_OIU-generate-init-loader-do)))

(defun _OIU-generate-init-loader-do ()
  (multiple-value-bind (_items _module-to-filename-alist _dep-alist)
      (OIU-get-module-lists
       (OIU-get-match-file-list
        (if (null OIU-init-file-directories)
            (list OIU-init-file-root-directory)
          (mapcar #'(lambda (d) (concat OIU-init-file-root-directory d))
                  OIU-init-file-directories))
        OIU-init-filename-regexp))
    (let (_result-stack)
      (_OIU-delete-dep-unresolvable-modules _items _dep-alist)
      ;;
      (OIU-check-illegal-dependency _items _dep-alist)
      ;;
      (multiple-value-setq (_items _result-stack)
        (OIU-add-independents-to-list _items _dep-alist))
      ;;
      (multiple-value-setq (_items _result-stack)
        (OIU-resolve-deps _items _dep-alist _result-stack))
      ;;
      (OIU-output-init-loader-elisp (nreverse _result-stack)
                                    _module-to-filename-alist
                                    OIU-init-loader-filename))))

(defun OIU-get-match-file-list (dirs regex)
  "Find and listing matched file from `DIRS' with `REGEX'."
  (let (_files)
    (dolist (_dir dirs _files)
      (setq _files (append _files (directory-files _dir t regex t))))))

(defun OIU-dependency-list ()
  "Get dependency list from current buffer."
  (when (re-search-forward
         (format "^%s\\(.*\\)$" (regexp-quote OIU-dependency-line-begin))
         nil t)
    (read (match-string 1))))

(defun OIU-get-module-lists (files)
  "Build dependency associated list from given file list.

\(OIU-get-module-lists FILES)

Dependency associated list:
  (\"module-name\" . (\"depended-module-name1\" \"..2\"...))"
  ;;
  (with-temp-buffer
    (let (_module-list _module-filename-alist _dependency-alist
                       _modn)
      (dolist (_fn files (values _module-list _module-filename-alist _dependency-alist))
        (setq _modn (file-name-sans-extension (file-name-nondirectory _fn)))
        (save-excursion
          (save-restriction
            (insert-file-contents _fn nil 0 1024 t) ; TODO: remove magic number 1024
            (goto-char 0)
            (when (member _modn _module-list)
              (error (format "ERROR: module-name (= dir/filename) confliction. `%s'" _modn)))
            (add-to-list '_module-list _modn)
            (add-to-list '_module-filename-alist (cons _modn _fn))
            (add-to-list '_dependency-alist
                         (cons _modn (OIU-dependency-list)))))))))

(defun _OIU-delete-dep-unresolvable-modules (modules modn-dep-alist)
  "Delete dependency unresovable items from argument."
  (let ((_c 1))
    (while (not (= _c 0))
      (setq _c 0)
      (dolist (m modules _c)
        (unless (subsetp (cdr (assoc m modn-dep-alist)) modules :test #'equal)
          (message "INFO: %s has unresolvable dependencies. It's ignored" m)
          (delete m modules)
          (delq (assoc m modn-dep-alist) modn-dep-alist)
          (incf _c))))))

(defun OIU-check-illegal-dependency (items modn-dep-alist)
  "Check dependency with (ITEMS MODN-DEP-ALIST)."
  (dolist (_item items t)
    (OIU-check-illegal-dependency-rec _item items modn-dep-alist nil)))

(defun OIU-check-illegal-dependency-rec (item all-items modn-dep-alist appeared)
  ""
  (if (member item appeared)
      (error "ERROR: Circular definition is detected. %s" (cons item appeared))
    (let ((_dep-lst (cdr (assoc item modn-dep-alist))))
      (if (null _dep-lst)
          t
        (dolist (_dep _dep-lst t)
          (OIU-check-illegal-dependency-rec
           _dep all-items modn-dep-alist (cons item appeared)))))))

(defun OIU-add-independents-to-list (items modn-dep-alist)
  (let (_remain-stack _result-stack)
    (while items
      (if (null (cdr (assoc (car items) modn-dep-alist)))
          (add-to-list '_result-stack (car items))
        (add-to-list '_remain-stack (car items)))
      (setq items (cdr items)))
    (values (nreverse _remain-stack) _result-stack)))

(defun OIU-resolve-deps (remains modn-dep-alist result-stack)
  (let (_passed-stack)
    (while remains
      (dolist (item remains)
        (if (subsetp (cdr (assoc item modn-dep-alist))
                     result-stack
                     :test 'equal)
            (progn
              (add-to-list 'result-stack item))
          (add-to-list '_passed-stack item)))
      (setq remains (nreverse _passed-stack))
      (setq _passed-stack nil))
    (values remains result-stack)))

(defun OIU-output-init-loader-elisp (load-order modn-filename-alist out-file)
  (setq coding-system-for-write 'utf-8-unix)
  (with-temp-file out-file
    (insert
     (format
      OIU-init-loader-file-header out-file))
    (dolist (_modn load-order t)
      (insert (format "(load %S)\n" (cdr (assoc _modn modn-filename-alist))))))
  (setq coding-system-for-write nil))

;;; OIU-gen-init-loader.el ends here
